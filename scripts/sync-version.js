#!/usr/bin/env node

/**
 * ç‰ˆæœ¬å·åŒæ­¥è„šæœ¬
 *
 * åŠŸèƒ½ï¼šä» package.json è¯»å–ç‰ˆæœ¬å·ï¼Œè‡ªåŠ¨åŒæ­¥åˆ°ï¼š
 * 1. manifest.jsonï¼ˆChrome æ‰©å±•è¦æ±‚ï¼‰
 * 2. src/shared/version.tsï¼ˆè¿è¡Œæ—¶å¸¸é‡ï¼‰
 *
 * è§¦å‘æ—¶æœºï¼š
 * - npm run build ä¹‹å‰ï¼ˆprebuild hookï¼‰
 * - npm run dev ä¹‹å‰ï¼ˆpredev hookï¼‰
 *
 * ä½¿ç”¨æ–¹å¼ï¼š
 * - è‡ªåŠ¨ï¼šé€šè¿‡ npm ç”Ÿå‘½å‘¨æœŸ hooks è‡ªåŠ¨è§¦å‘
 * - æ‰‹åŠ¨ï¼šnpm run sync:version
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// ESM ç¯å¢ƒä¸‹è·å– __dirname
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// é¡¹ç›®æ ¹ç›®å½•
const ROOT_DIR = path.resolve(__dirname, '..');

/**
 * è¯»å– JSON æ–‡ä»¶
 */
function readJSON(filePath) {
  const fullPath = path.resolve(ROOT_DIR, filePath);
  const content = fs.readFileSync(fullPath, 'utf-8');
  return JSON.parse(content);
}

/**
 * å†™å…¥ JSON æ–‡ä»¶ï¼ˆæ ¼å¼åŒ–ï¼‰
 */
function writeJSON(filePath, data) {
  const fullPath = path.resolve(ROOT_DIR, filePath);
  const content = JSON.stringify(data, null, 2) + '\n';
  fs.writeFileSync(fullPath, content, 'utf-8');
}

/**
 * å†™å…¥æ–‡æœ¬æ–‡ä»¶
 */
function writeText(filePath, content) {
  const fullPath = path.resolve(ROOT_DIR, filePath);
  // ç¡®ä¿ç›®å½•å­˜åœ¨
  const dir = path.dirname(fullPath);
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }
  fs.writeFileSync(fullPath, content, 'utf-8');
}

/**
 * ä¸»æ‰§è¡Œé€»è¾‘
 */
function syncVersion() {
  console.log('ğŸ”„ Starting version synchronization...\n');

  // 1. è¯»å– package.json ä¸­çš„ç‰ˆæœ¬å·
  const packageJson = readJSON('package.json');
  const version = packageJson.version;

  if (!version) {
    console.error('âŒ Error: No version found in package.json');
    process.exit(1);
  }

  console.log(`ğŸ“¦ Source version from package.json: ${version}`);

  // 2. åŒæ­¥åˆ° manifest.json
  try {
    const manifest = readJSON('manifest.json');
    const oldManifestVersion = manifest.version;

    manifest.version = version;
    writeJSON('manifest.json', manifest);

    if (oldManifestVersion !== version) {
      console.log(`âœ… manifest.json: ${oldManifestVersion} â†’ ${version}`);
    } else {
      console.log(`âœ“  manifest.json: ${version} (unchanged)`);
    }
  } catch (error) {
    console.error('âŒ Error syncing manifest.json:', error.message);
    process.exit(1);
  }

  // 3. ç”Ÿæˆ src/shared/version.ts
  try {
    const versionTsContent = `/**
 * Application Version Constants
 *
 * âš ï¸ AUTO-GENERATED FILE - DO NOT EDIT MANUALLY
 *
 * This file is automatically generated by scripts/sync-version.js
 * Source of truth: package.json "version" field
 *
 * To update version:
 * 1. Edit version in package.json
 * 2. Run: npm run sync:version (or automatically via prebuild/predev)
 *
 * Generated at: ${new Date().toISOString()}
 */

/**
 * Application version number (e.g., "0.1.0")
 */
export const APP_VERSION = '${version}' as const;

/**
 * Application version with 'v' prefix (e.g., "v0.1.0")
 * Commonly used for display purposes
 */
export const APP_VERSION_WITH_PREFIX = 'v${version}' as const;

/**
 * Parse version into components
 */
export const VERSION_PARTS = {
  major: ${version.split('.')[0] || 0},
  minor: ${version.split('.')[1] || 0},
  patch: ${version.split('.')[2] || 0},
} as const;
`;

    writeText('src/shared/version.ts', versionTsContent);
    console.log(`âœ… src/shared/version.ts: Generated with version ${version}`);
  } catch (error) {
    console.error('âŒ Error generating version.ts:', error.message);
    process.exit(1);
  }

  console.log('\nâœ¨ Version synchronization completed successfully!\n');
}

// æ‰§è¡ŒåŒæ­¥
try {
  syncVersion();
} catch (error) {
  console.error('\nâŒ Fatal error:', error.message);
  process.exit(1);
}
